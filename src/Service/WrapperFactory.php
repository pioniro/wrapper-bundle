<?php

declare(strict_types=1);

namespace Pioniro\WrapperBundle\Service;

use Pioniro\WrapperBundle\Exception\InvalidArgumentException;
use Pioniro\WrapperBundle\Exception\UnexpectedValueException;

class WrapperFactory
{
    protected string $proxyClassTemplate = <<<'PHP'
<?php

namespace <namespace>;

/**
 * DO NOT EDIT THIS FILE - IT WAS CREATED BY PROXY GENERATOR
 */
class <proxyShortClassName> extends \<className>
{
    private array $__handlers = [];

    public function __addHandler(string $method, \Pioniro\WrapperBundle\HandlerInterface $handler, string $annotation): void
    {
        if (!isset($this->__handlers[$method])) {
            $this->__handlers[$method] = [];
        }
        $this->__handlers[$method][] = [$handler, $annotation];
    }

<methods>
}
PHP;

    private string $methodTemplate = <<<'PHP'
    <modificator> function <methodName>(<methodParameters>) <methodReturnType>
    {
        $f = fn() => parent::<methodName>(<methodArguments>);
        $args = func_get_args();

        foreach ($this->__handlers['<methodName>'] ?? [] as &$h) {
            [$handler, $annotation] = $h;
            if (is_string($annotation)) {
                $annotation = unserialize($annotation);
                $h[1] = $annotation;
            }
            $f = $handler->handle($f, __METHOD__, $args, $annotation);
        }
        return $f();
    }
PHP;

    private string $methodVoidTemplate = <<<'PHP'
    public function <methodName>(<methodParameters>) <methodReturnType>
    {
        $f = fn() => parent::<methodName>(<methodArguments>);
        $args = func_get_args();

        foreach ($this->__handlers['<methodName>'] ?? [] as &$h) {
            [$handler, $annotation] = $h;
            if (is_string($annotation)) {
                $annotation = unserialize($annotation);
                $h[1] = $annotation;
            }
            $f = $handler->handle($f, __METHOD__, $args, $annotation);
        }
        $f();
    }
PHP;

    private string $proxyDirectory;
    private string $proxyNamespace;

    public function __construct(string $proxyDirectory, string $proxyNamespace)
    {
        if (!$proxyDirectory) {
            throw InvalidArgumentException::proxyDirectoryRequired();
        }

        if (!$proxyNamespace) {
            throw InvalidArgumentException::proxyNamespaceRequired();
        }
        $this->proxyDirectory = rtrim($proxyDirectory, '/');
        $this->proxyNamespace = $proxyNamespace;
    }

    /**
     * @param \ReflectionClass $class
     * @param string[]         $methods
     *
     * @return string[]
     */
    public function wrap(\ReflectionClass $class, array $methods): array
    {
        $this->verifyClassCanBeProxied($class);
        $methods = array_map(fn ($method) => $class->getMethod($method), $methods);
        $methods = $this->generateMethods($methods);
        $className = $class->getName();
        $ns = strrev(explode('\\', strrev($className), 2)[1]);
        $shortName = $class->getShortName();
        $template = $this->proxyClassTemplate;
        $proxyClass = $this->proxyNamespace . '\\' . $ns . '\\' . $shortName;
        $template = str_replace('<namespace>', $this->proxyNamespace . '\\' . $ns, $template);
        $template = str_replace('<proxyShortClassName>', $shortName, $template);
        $template = str_replace('<className>', $className, $template);
        $template = str_replace('<methods>', $methods, $template);

        $parentDirectory = $this->proxyDirectory . '/' . str_replace('\\', '/', str_replace('..', '', $ns));
        $fileName = $parentDirectory . '/' . $shortName . '.php';

        if (!is_dir($parentDirectory) && (false === @mkdir($parentDirectory, 0775, true))) {
            throw UnexpectedValueException::proxyDirectoryNotWritable($this->proxyDirectory);
        }

        if (!is_writable($parentDirectory)) {
            throw UnexpectedValueException::proxyDirectoryNotWritable($this->proxyDirectory);
        }

        $tmpFileName = $fileName . '.' . bin2hex(random_bytes(12));

        file_put_contents($tmpFileName, $template);
        @chmod($tmpFileName, 0664);
        rename($tmpFileName, $fileName);

        return [$proxyClass, $fileName];
    }

    /**
     * @throws InvalidArgumentException
     */
    private function verifyClassCanBeProxied(\ReflectionClass $class): void
    {
        if ($class->isFinal()) {
            throw InvalidArgumentException::classMustNotBeFinal($class->getName());
        }

        if ($class->isAbstract()) {
            throw InvalidArgumentException::classMustNotBeAbstract($class->getName());
        }

        if (\PHP_VERSION_ID >= 80200 && $class->isReadOnly()) {
            throw InvalidArgumentException::classMustNotBeReadOnly($class->getName());
        }
    }

    /**
     * @param array|\ReflectionMethod[] $methods
     */
    private function generateMethods(array $methods): string
    {
        $body = [];
        foreach ($methods as $method) {
            $body[] = $this->generateMethod($method);
        }

        return implode("\n\n", $body);
    }

    private function generateMethod(\ReflectionMethod $method): string
    {
        $arguments = [];
        foreach ($method->getParameters() as $parameter) {
            if ($parameter->isVariadic()) {
                $arguments[] = '...$' . $parameter->getName();
            } else {
                $arguments[] = '$' . $parameter->getName();
            }
        }
        $arguments = implode(', ', $arguments);
        $parameters = $this->buildParametersString($method->getParameters());
        $returnType = $this->getMethodReturnType($method);
        $modificator = $method->isPublic() ? 'public' : 'protected';
        $template = $this->methodTemplate;
        if ($method->getReturnType() && 'void' === $method->getReturnType()->getName()) {
            $template = $this->methodVoidTemplate;
        }

        return str_replace(
            ['<methodName>', '<methodParameters>', '<methodArguments>', '<methodReturnType>', '<modificator>'],
            [$method->getName(), $parameters, $arguments, $returnType, $modificator],
            $template
        );
    }

    private function getMethodReturnType(\ReflectionMethod $method): string
    {
        if (!$method->getReturnType()) {
            return '';
        }

        return ': ' . $this->formatType($method->getReturnType(), $method);
    }

    /**
     * @param \ReflectionParameter[] $parameters
     * @param string[]               $renameParameters
     *
     * @return string
     */
    private function buildParametersString(array $parameters, array $renameParameters = []): string
    {
        $parameterDefinitions = [];

        $i = -1;
        foreach ($parameters as $param) {
            ++$i;
            $parameterDefinition = '';
            $parameterType = $this->getParameterType($param);

            if (null !== $parameterType) {
                $parameterDefinition .= $parameterType . ' ';
            }

            if ($param->isPassedByReference()) {
                $parameterDefinition .= '&';
            }

            if ($param->isVariadic()) {
                $parameterDefinition .= '...';
            }

            $parameterDefinition .= '$' . ($renameParameters ? $renameParameters[$i] : $param->getName());
            $parameterDefinition .= $this->getParameterDefaultValue($param);

            $parameterDefinitions[] = $parameterDefinition;
        }

        return implode(', ', $parameterDefinitions);
    }

    private function getParameterType(\ReflectionParameter $parameter): ?string
    {
        if (!$parameter->getType()) {
            return null;
        }

        $declaringFunction = $parameter->getDeclaringFunction();

        \assert($declaringFunction instanceof \ReflectionMethod);

        return $this->formatType($parameter->getType(), $declaringFunction, $parameter);
    }

    private function getParameterDefaultValue(\ReflectionParameter $parameter): string
    {
        if (!$parameter->isDefaultValueAvailable()) {
            return '';
        }

        if (\PHP_VERSION_ID < 80100 || \is_scalar($parameter->getDefaultValue())) {
            return ' = ' . var_export($parameter->getDefaultValue(), true);
        }

        $value = rtrim(substr(explode('$' . $parameter->getName() . ' = ', (string) $parameter, 2)[1], 0, -2));

        if (str_contains($value, '\\') || str_contains($value, '::')) {
            $value = preg_split("/('(?:[^'\\\\]*+(?:\\\\.)*+)*+')/", $value, -1, \PREG_SPLIT_DELIM_CAPTURE);
            foreach ($value as $i => $part) {
                if (0 === $i % 2) {
                    $value[$i] = preg_replace('/(?<![a-zA-Z0-9_\x7f-\xff\\\\])[a-zA-Z0-9_\x7f-\xff]++(?:\\\\[a-zA-Z0-9_\x7f-\xff]++|::)++/', '\\\\\0', $part);
                }
            }

            $value = implode('', $value);
        }

        return ' = ' . $value;
    }

    /**
     * @return string
     */
    private function formatType(
        \ReflectionType $type,
        \ReflectionMethod $method,
        ?\ReflectionParameter $parameter = null
    ): string {
        if ($type instanceof \ReflectionUnionType) {
            return implode('|', array_map(
                function (\ReflectionType $unionedType) use ($method, $parameter) {
                    if ($unionedType instanceof \ReflectionIntersectionType) {
                        return '(' . $this->formatType($unionedType, $method, $parameter) . ')';
                    }

                    return $this->formatType($unionedType, $method, $parameter);
                },
                $type->getTypes()
            ));
        }

        if ($type instanceof \ReflectionIntersectionType) {
            return implode('&', array_map(
                function (\ReflectionType $intersectedType) use ($method, $parameter) {
                    return $this->formatType($intersectedType, $method, $parameter);
                },
                $type->getTypes()
            ));
        }

        \assert($type instanceof \ReflectionNamedType);

        $name = $type->getName();
        $nameLower = strtolower($name);

        if ('static' === $nameLower) {
            $name = 'static';
        }

        if ('self' === $nameLower) {
            $name = $method->getDeclaringClass()->getName();
        }

        if ('parent' === $nameLower) {
            $name = $method->getDeclaringClass()->getParentClass()->getName();
        }

        if (!$type->isBuiltin() && !class_exists($name) && !interface_exists($name) && 'static' !== $name) {
            if (null !== $parameter) {
                throw UnexpectedValueException::invalidParameterTypeHint($method->getDeclaringClass()->getName(), $method->getName(), $parameter->getName());
            }

            throw UnexpectedValueException::invalidReturnTypeHint($method->getDeclaringClass()->getName(), $method->getName());
        }

        if (!$type->isBuiltin() && 'static' !== $name) {
            $name = '\\' . $name;
        }

        if (
            $type->allowsNull()
            && !\in_array($name, ['mixed', 'null'], true)
            && (null === $parameter || !$parameter->isDefaultValueAvailable() || null !== $parameter->getDefaultValue())
        ) {
            $name = '?' . $name;
        }

        return $name;
    }
}
